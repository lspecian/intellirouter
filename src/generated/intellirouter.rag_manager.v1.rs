// This file is @generated by prost-build.
/// Document represents a document for RAG
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    /// Unique identifier for the document
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Content of the document
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    /// Metadata about the document
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// When the document was created
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// When the document was last updated
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Document embedding (if available)
    #[prost(float, repeated, tag = "6")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    /// Document chunks (if chunked)
    #[prost(message, repeated, tag = "7")]
    pub chunks: ::prost::alloc::vec::Vec<DocumentChunk>,
}
/// DocumentChunk represents a chunk of a document
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentChunk {
    /// Unique identifier for the chunk
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Content of the chunk
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    /// Metadata about the chunk
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Chunk embedding (if available)
    #[prost(float, repeated, tag = "4")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    /// Parent document ID
    #[prost(string, tag = "5")]
    pub document_id: ::prost::alloc::string::String,
    /// Chunk index within the document
    #[prost(uint32, tag = "6")]
    pub chunk_index: u32,
}
/// IndexDocumentRequest is sent to index a document
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexDocumentRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Document to index
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    /// Chunk size in characters (0 for no chunking)
    #[prost(uint32, tag = "3")]
    pub chunk_size: u32,
    /// Chunk overlap in characters
    #[prost(uint32, tag = "4")]
    pub chunk_overlap: u32,
    /// Whether to compute embeddings
    #[prost(bool, tag = "5")]
    pub compute_embeddings: bool,
    /// Model to use for embeddings (if compute_embeddings is true)
    #[prost(string, tag = "6")]
    pub embedding_model: ::prost::alloc::string::String,
}
/// IndexDocumentResponse is returned after indexing a document
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexDocumentResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Document ID
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
    /// Number of chunks created
    #[prost(uint32, tag = "3")]
    pub chunk_count: u32,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// RetrieveDocumentsRequest is sent to retrieve relevant documents
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveDocumentsRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Query text
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Number of documents to retrieve
    #[prost(uint32, tag = "3")]
    pub top_k: u32,
    /// Minimum similarity score (0.0 to 1.0)
    #[prost(float, tag = "4")]
    pub min_score: f32,
    /// Filter by metadata
    #[prost(map = "string, string", tag = "5")]
    pub metadata_filter: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Whether to include document content
    #[prost(bool, tag = "6")]
    pub include_content: bool,
    /// Whether to rerank results
    #[prost(bool, tag = "7")]
    pub rerank: bool,
    /// Model to use for reranking (if rerank is true)
    #[prost(string, tag = "8")]
    pub rerank_model: ::prost::alloc::string::String,
}
/// RetrieveDocumentsResponse is returned with retrieved documents
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveDocumentsResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Retrieved documents with similarity scores
    #[prost(message, repeated, tag = "2")]
    pub documents: ::prost::alloc::vec::Vec<ScoredDocument>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// ScoredDocument represents a document with a similarity score
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoredDocument {
    /// Document
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    /// Similarity score (0.0 to 1.0)
    #[prost(float, tag = "2")]
    pub score: f32,
}
/// AugmentRequestRequest is sent to augment a request with context
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AugmentRequestRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Original request text
    #[prost(string, tag = "2")]
    pub request: ::prost::alloc::string::String,
    /// Number of documents to retrieve
    #[prost(uint32, tag = "3")]
    pub top_k: u32,
    /// Minimum similarity score (0.0 to 1.0)
    #[prost(float, tag = "4")]
    pub min_score: f32,
    /// Filter by metadata
    #[prost(map = "string, string", tag = "5")]
    pub metadata_filter: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Whether to include citations
    #[prost(bool, tag = "6")]
    pub include_citations: bool,
    /// Maximum context length in characters
    #[prost(uint32, tag = "7")]
    pub max_context_length: u32,
    /// Context template (optional)
    #[prost(string, tag = "8")]
    pub context_template: ::prost::alloc::string::String,
}
/// AugmentRequestResponse is returned with the augmented request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AugmentRequestResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Augmented request text
    #[prost(string, tag = "2")]
    pub augmented_request: ::prost::alloc::string::String,
    /// Retrieved documents with similarity scores
    #[prost(message, repeated, tag = "3")]
    pub documents: ::prost::alloc::vec::Vec<ScoredDocument>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// GetDocumentByIdRequest is sent to retrieve a document by ID
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentByIdRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Document ID
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
    /// Whether to include chunks
    #[prost(bool, tag = "3")]
    pub include_chunks: bool,
}
/// GetDocumentByIdResponse is returned with the requested document
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentByIdResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Document
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// DeleteDocumentRequest is sent to delete a document
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Document ID
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
}
/// DeleteDocumentResponse is returned after deleting a document
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// ListDocumentsRequest is sent to list documents
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Maximum number of documents to return
    #[prost(uint32, tag = "2")]
    pub limit: u32,
    /// Offset for pagination
    #[prost(uint32, tag = "3")]
    pub offset: u32,
    /// Filter by metadata
    #[prost(map = "string, string", tag = "4")]
    pub metadata_filter: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ListDocumentsResponse is returned with the list of documents
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Documents
    #[prost(message, repeated, tag = "2")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    /// Total number of documents matching the filter
    #[prost(uint32, tag = "3")]
    pub total_count: u32,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// Persona represents a persona configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Persona {
    /// Unique identifier for the persona
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the persona
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Description of the persona
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// System prompt for the persona
    #[prost(string, tag = "4")]
    pub system_prompt: ::prost::alloc::string::String,
    /// Response format for the persona (optional)
    #[prost(string, tag = "5")]
    pub response_format: ::prost::alloc::string::String,
    /// When the persona was created
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// When the persona was last updated
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Additional metadata about the persona
    #[prost(map = "string, string", tag = "8")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Tags for categorization
    #[prost(string, repeated, tag = "9")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Version of the persona
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<super::super::common::v1::VersionInfo>,
}
/// CreatePersonaRequest is sent to create a new persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePersonaRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Name of the persona
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Description of the persona
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// System prompt for the persona
    #[prost(string, tag = "4")]
    pub system_prompt: ::prost::alloc::string::String,
    /// Response format for the persona (optional)
    #[prost(string, tag = "5")]
    pub response_format: ::prost::alloc::string::String,
    /// Additional metadata about the persona
    #[prost(map = "string, string", tag = "6")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Tags for categorization
    #[prost(string, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// CreatePersonaResponse is returned after creating a persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePersonaResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Created persona
    #[prost(message, optional, tag = "2")]
    pub persona: ::core::option::Option<Persona>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// GetPersonaRequest is sent to get a persona by ID
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPersonaRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Persona ID
    #[prost(string, tag = "2")]
    pub persona_id: ::prost::alloc::string::String,
}
/// GetPersonaResponse is returned with the requested persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPersonaResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Persona
    #[prost(message, optional, tag = "2")]
    pub persona: ::core::option::Option<Persona>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// UpdatePersonaRequest is sent to update an existing persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePersonaRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Persona ID
    #[prost(string, tag = "2")]
    pub persona_id: ::prost::alloc::string::String,
    /// Name of the persona (optional)
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Description of the persona (optional)
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// System prompt for the persona (optional)
    #[prost(string, optional, tag = "5")]
    pub system_prompt: ::core::option::Option<::prost::alloc::string::String>,
    /// Response format for the persona (optional)
    #[prost(string, optional, tag = "6")]
    pub response_format: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional metadata about the persona (optional)
    #[prost(map = "string, string", tag = "7")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Tags for categorization (optional)
    #[prost(string, repeated, tag = "8")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// UpdatePersonaResponse is returned after updating a persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePersonaResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Updated persona
    #[prost(message, optional, tag = "2")]
    pub persona: ::core::option::Option<Persona>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// DeletePersonaRequest is sent to delete a persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePersonaRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Persona ID
    #[prost(string, tag = "2")]
    pub persona_id: ::prost::alloc::string::String,
}
/// DeletePersonaResponse is returned after deleting a persona
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePersonaResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// ListPersonasRequest is sent to list personas
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPersonasRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Maximum number of personas to return
    #[prost(uint32, tag = "2")]
    pub limit: u32,
    /// Offset for pagination
    #[prost(uint32, tag = "3")]
    pub offset: u32,
    /// Filter by tags
    #[prost(string, repeated, tag = "4")]
    pub tag_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ListPersonasResponse is returned with the list of personas
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPersonasResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Personas
    #[prost(message, repeated, tag = "2")]
    pub personas: ::prost::alloc::vec::Vec<Persona>,
    /// Total number of personas matching the filter
    #[prost(uint32, tag = "3")]
    pub total_count: u32,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// ApplyPersonaRequest is sent to apply a persona to a request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyPersonaRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Original request text
    #[prost(string, tag = "4")]
    pub request: ::prost::alloc::string::String,
    /// Additional context to include (optional)
    #[prost(string, tag = "5")]
    pub additional_context: ::prost::alloc::string::String,
    /// Whether to include the persona description in the prompt
    #[prost(bool, tag = "6")]
    pub include_description: bool,
    /// Persona identifier
    #[prost(oneof = "apply_persona_request::PersonaIdentifier", tags = "2, 3")]
    pub persona_identifier: ::core::option::Option<
        apply_persona_request::PersonaIdentifier,
    >,
}
/// Nested message and enum types in `ApplyPersonaRequest`.
pub mod apply_persona_request {
    /// Persona identifier
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PersonaIdentifier {
        /// Persona ID
        #[prost(string, tag = "2")]
        PersonaId(::prost::alloc::string::String),
        /// Inline persona definition
        #[prost(message, tag = "3")]
        Persona(super::Persona),
    }
}
/// ApplyPersonaResponse is returned with the personalized request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyPersonaResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Personalized request text
    #[prost(string, tag = "2")]
    pub personalized_request: ::prost::alloc::string::String,
    /// Applied persona
    #[prost(message, optional, tag = "3")]
    pub applied_persona: ::core::option::Option<Persona>,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// AugmentPersonaRequestRequest is sent to augment a persona request with RAG context
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AugmentPersonaRequestRequest {
    /// Request context
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<super::super::common::v1::RequestContext>,
    /// Persona ID
    #[prost(string, tag = "2")]
    pub persona_id: ::prost::alloc::string::String,
    /// Original request text
    #[prost(string, tag = "3")]
    pub request: ::prost::alloc::string::String,
    /// Number of documents to retrieve
    #[prost(uint32, tag = "4")]
    pub top_k: u32,
    /// Minimum similarity score (0.0 to 1.0)
    #[prost(float, tag = "5")]
    pub min_score: f32,
    /// Filter by metadata
    #[prost(map = "string, string", tag = "6")]
    pub metadata_filter: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Whether to include citations
    #[prost(bool, tag = "7")]
    pub include_citations: bool,
    /// Maximum context length in characters
    #[prost(uint32, tag = "8")]
    pub max_context_length: u32,
    /// Context template (optional)
    #[prost(string, tag = "9")]
    pub context_template: ::prost::alloc::string::String,
}
/// AugmentPersonaRequestResponse is returned with the augmented persona request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AugmentPersonaRequestResponse {
    /// Status of the operation
    #[prost(enumeration = "super::super::common::v1::Status", tag = "1")]
    pub status: i32,
    /// Augmented and personalized request text
    #[prost(string, tag = "2")]
    pub augmented_request: ::prost::alloc::string::String,
    /// Applied persona ID
    #[prost(string, tag = "3")]
    pub persona_id: ::prost::alloc::string::String,
    /// Number of documents retrieved
    #[prost(uint32, tag = "4")]
    pub document_count: u32,
    /// Error details (if status is ERROR)
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::common::v1::ErrorDetails>,
}
/// Generated client implementations.
pub mod rag_manager_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// RAGManagerService provides methods for RAG operations
    #[derive(Debug, Clone)]
    pub struct RagManagerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RagManagerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RagManagerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RagManagerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RagManagerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// IndexDocument indexes a document for retrieval
        pub async fn index_document(
            &mut self,
            request: impl tonic::IntoRequest<super::IndexDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IndexDocumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGManagerService/IndexDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGManagerService",
                        "IndexDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RetrieveDocuments retrieves relevant documents for a query
        pub async fn retrieve_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGManagerService/RetrieveDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGManagerService",
                        "RetrieveDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AugmentRequest augments a request with retrieved context
        pub async fn augment_request(
            &mut self,
            request: impl tonic::IntoRequest<super::AugmentRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AugmentRequestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGManagerService/AugmentRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGManagerService",
                        "AugmentRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetDocumentById retrieves a document by its ID
        pub async fn get_document_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDocumentByIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGManagerService/GetDocumentById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGManagerService",
                        "GetDocumentById",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeleteDocument deletes a document from the index
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteDocumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGManagerService/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGManagerService",
                        "DeleteDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListDocuments lists all documents in the index
        pub async fn list_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGManagerService/ListDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGManagerService",
                        "ListDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod persona_layer_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// PersonaLayerService provides methods for persona management
    #[derive(Debug, Clone)]
    pub struct PersonaLayerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PersonaLayerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PersonaLayerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PersonaLayerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PersonaLayerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// CreatePersona creates a new persona
        pub async fn create_persona(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePersonaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.PersonaLayerService/CreatePersona",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.PersonaLayerService",
                        "CreatePersona",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetPersona gets a persona by ID
        pub async fn get_persona(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPersonaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.PersonaLayerService/GetPersona",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.PersonaLayerService",
                        "GetPersona",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdatePersona updates an existing persona
        pub async fn update_persona(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePersonaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.PersonaLayerService/UpdatePersona",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.PersonaLayerService",
                        "UpdatePersona",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeletePersona deletes a persona
        pub async fn delete_persona(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePersonaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.PersonaLayerService/DeletePersona",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.PersonaLayerService",
                        "DeletePersona",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListPersonas lists all personas
        pub async fn list_personas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPersonasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPersonasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.PersonaLayerService/ListPersonas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.PersonaLayerService",
                        "ListPersonas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ApplyPersona applies a persona to a request
        pub async fn apply_persona(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyPersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApplyPersonaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.PersonaLayerService/ApplyPersona",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.PersonaLayerService",
                        "ApplyPersona",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod rag_persona_integration_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// RAGPersonaIntegrationService provides methods for integrating RAG and Persona
    #[derive(Debug, Clone)]
    pub struct RagPersonaIntegrationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RagPersonaIntegrationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RagPersonaIntegrationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RagPersonaIntegrationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RagPersonaIntegrationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// AugmentPersonaRequest augments a persona request with RAG context
        pub async fn augment_persona_request(
            &mut self,
            request: impl tonic::IntoRequest<super::AugmentPersonaRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AugmentPersonaRequestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/intellirouter.rag_manager.v1.RAGPersonaIntegrationService/AugmentPersonaRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "intellirouter.rag_manager.v1.RAGPersonaIntegrationService",
                        "AugmentPersonaRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod rag_manager_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RagManagerServiceServer.
    #[async_trait]
    pub trait RagManagerService: Send + Sync + 'static {
        /// IndexDocument indexes a document for retrieval
        async fn index_document(
            &self,
            request: tonic::Request<super::IndexDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IndexDocumentResponse>,
            tonic::Status,
        >;
        /// RetrieveDocuments retrieves relevant documents for a query
        async fn retrieve_documents(
            &self,
            request: tonic::Request<super::RetrieveDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveDocumentsResponse>,
            tonic::Status,
        >;
        /// AugmentRequest augments a request with retrieved context
        async fn augment_request(
            &self,
            request: tonic::Request<super::AugmentRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AugmentRequestResponse>,
            tonic::Status,
        >;
        /// GetDocumentById retrieves a document by its ID
        async fn get_document_by_id(
            &self,
            request: tonic::Request<super::GetDocumentByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDocumentByIdResponse>,
            tonic::Status,
        >;
        /// DeleteDocument deletes a document from the index
        async fn delete_document(
            &self,
            request: tonic::Request<super::DeleteDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteDocumentResponse>,
            tonic::Status,
        >;
        /// ListDocuments lists all documents in the index
        async fn list_documents(
            &self,
            request: tonic::Request<super::ListDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentsResponse>,
            tonic::Status,
        >;
    }
    /// RAGManagerService provides methods for RAG operations
    #[derive(Debug)]
    pub struct RagManagerServiceServer<T: RagManagerService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: RagManagerService> RagManagerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for RagManagerServiceServer<T>
    where
        T: RagManagerService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/intellirouter.rag_manager.v1.RAGManagerService/IndexDocument" => {
                    #[allow(non_camel_case_types)]
                    struct IndexDocumentSvc<T: RagManagerService>(pub Arc<T>);
                    impl<
                        T: RagManagerService,
                    > tonic::server::UnaryService<super::IndexDocumentRequest>
                    for IndexDocumentSvc<T> {
                        type Response = super::IndexDocumentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::IndexDocumentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagManagerService>::index_document(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = IndexDocumentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.RAGManagerService/RetrieveDocuments" => {
                    #[allow(non_camel_case_types)]
                    struct RetrieveDocumentsSvc<T: RagManagerService>(pub Arc<T>);
                    impl<
                        T: RagManagerService,
                    > tonic::server::UnaryService<super::RetrieveDocumentsRequest>
                    for RetrieveDocumentsSvc<T> {
                        type Response = super::RetrieveDocumentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RetrieveDocumentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagManagerService>::retrieve_documents(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RetrieveDocumentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.RAGManagerService/AugmentRequest" => {
                    #[allow(non_camel_case_types)]
                    struct AugmentRequestSvc<T: RagManagerService>(pub Arc<T>);
                    impl<
                        T: RagManagerService,
                    > tonic::server::UnaryService<super::AugmentRequestRequest>
                    for AugmentRequestSvc<T> {
                        type Response = super::AugmentRequestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AugmentRequestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagManagerService>::augment_request(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AugmentRequestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.RAGManagerService/GetDocumentById" => {
                    #[allow(non_camel_case_types)]
                    struct GetDocumentByIdSvc<T: RagManagerService>(pub Arc<T>);
                    impl<
                        T: RagManagerService,
                    > tonic::server::UnaryService<super::GetDocumentByIdRequest>
                    for GetDocumentByIdSvc<T> {
                        type Response = super::GetDocumentByIdResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDocumentByIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagManagerService>::get_document_by_id(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetDocumentByIdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.RAGManagerService/DeleteDocument" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteDocumentSvc<T: RagManagerService>(pub Arc<T>);
                    impl<
                        T: RagManagerService,
                    > tonic::server::UnaryService<super::DeleteDocumentRequest>
                    for DeleteDocumentSvc<T> {
                        type Response = super::DeleteDocumentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteDocumentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagManagerService>::delete_document(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteDocumentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.RAGManagerService/ListDocuments" => {
                    #[allow(non_camel_case_types)]
                    struct ListDocumentsSvc<T: RagManagerService>(pub Arc<T>);
                    impl<
                        T: RagManagerService,
                    > tonic::server::UnaryService<super::ListDocumentsRequest>
                    for ListDocumentsSvc<T> {
                        type Response = super::ListDocumentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListDocumentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagManagerService>::list_documents(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListDocumentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: RagManagerService> Clone for RagManagerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: RagManagerService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: RagManagerService> tonic::server::NamedService
    for RagManagerServiceServer<T> {
        const NAME: &'static str = "intellirouter.rag_manager.v1.RAGManagerService";
    }
}
/// Generated server implementations.
pub mod persona_layer_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PersonaLayerServiceServer.
    #[async_trait]
    pub trait PersonaLayerService: Send + Sync + 'static {
        /// CreatePersona creates a new persona
        async fn create_persona(
            &self,
            request: tonic::Request<super::CreatePersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePersonaResponse>,
            tonic::Status,
        >;
        /// GetPersona gets a persona by ID
        async fn get_persona(
            &self,
            request: tonic::Request<super::GetPersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPersonaResponse>,
            tonic::Status,
        >;
        /// UpdatePersona updates an existing persona
        async fn update_persona(
            &self,
            request: tonic::Request<super::UpdatePersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePersonaResponse>,
            tonic::Status,
        >;
        /// DeletePersona deletes a persona
        async fn delete_persona(
            &self,
            request: tonic::Request<super::DeletePersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePersonaResponse>,
            tonic::Status,
        >;
        /// ListPersonas lists all personas
        async fn list_personas(
            &self,
            request: tonic::Request<super::ListPersonasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPersonasResponse>,
            tonic::Status,
        >;
        /// ApplyPersona applies a persona to a request
        async fn apply_persona(
            &self,
            request: tonic::Request<super::ApplyPersonaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApplyPersonaResponse>,
            tonic::Status,
        >;
    }
    /// PersonaLayerService provides methods for persona management
    #[derive(Debug)]
    pub struct PersonaLayerServiceServer<T: PersonaLayerService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: PersonaLayerService> PersonaLayerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for PersonaLayerServiceServer<T>
    where
        T: PersonaLayerService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/intellirouter.rag_manager.v1.PersonaLayerService/CreatePersona" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePersonaSvc<T: PersonaLayerService>(pub Arc<T>);
                    impl<
                        T: PersonaLayerService,
                    > tonic::server::UnaryService<super::CreatePersonaRequest>
                    for CreatePersonaSvc<T> {
                        type Response = super::CreatePersonaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreatePersonaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PersonaLayerService>::create_persona(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreatePersonaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.PersonaLayerService/GetPersona" => {
                    #[allow(non_camel_case_types)]
                    struct GetPersonaSvc<T: PersonaLayerService>(pub Arc<T>);
                    impl<
                        T: PersonaLayerService,
                    > tonic::server::UnaryService<super::GetPersonaRequest>
                    for GetPersonaSvc<T> {
                        type Response = super::GetPersonaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPersonaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PersonaLayerService>::get_persona(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetPersonaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.PersonaLayerService/UpdatePersona" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePersonaSvc<T: PersonaLayerService>(pub Arc<T>);
                    impl<
                        T: PersonaLayerService,
                    > tonic::server::UnaryService<super::UpdatePersonaRequest>
                    for UpdatePersonaSvc<T> {
                        type Response = super::UpdatePersonaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdatePersonaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PersonaLayerService>::update_persona(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdatePersonaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.PersonaLayerService/DeletePersona" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePersonaSvc<T: PersonaLayerService>(pub Arc<T>);
                    impl<
                        T: PersonaLayerService,
                    > tonic::server::UnaryService<super::DeletePersonaRequest>
                    for DeletePersonaSvc<T> {
                        type Response = super::DeletePersonaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePersonaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PersonaLayerService>::delete_persona(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeletePersonaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.PersonaLayerService/ListPersonas" => {
                    #[allow(non_camel_case_types)]
                    struct ListPersonasSvc<T: PersonaLayerService>(pub Arc<T>);
                    impl<
                        T: PersonaLayerService,
                    > tonic::server::UnaryService<super::ListPersonasRequest>
                    for ListPersonasSvc<T> {
                        type Response = super::ListPersonasResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListPersonasRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PersonaLayerService>::list_personas(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListPersonasSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/intellirouter.rag_manager.v1.PersonaLayerService/ApplyPersona" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyPersonaSvc<T: PersonaLayerService>(pub Arc<T>);
                    impl<
                        T: PersonaLayerService,
                    > tonic::server::UnaryService<super::ApplyPersonaRequest>
                    for ApplyPersonaSvc<T> {
                        type Response = super::ApplyPersonaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApplyPersonaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PersonaLayerService>::apply_persona(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ApplyPersonaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: PersonaLayerService> Clone for PersonaLayerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: PersonaLayerService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: PersonaLayerService> tonic::server::NamedService
    for PersonaLayerServiceServer<T> {
        const NAME: &'static str = "intellirouter.rag_manager.v1.PersonaLayerService";
    }
}
/// Generated server implementations.
pub mod rag_persona_integration_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RagPersonaIntegrationServiceServer.
    #[async_trait]
    pub trait RagPersonaIntegrationService: Send + Sync + 'static {
        /// AugmentPersonaRequest augments a persona request with RAG context
        async fn augment_persona_request(
            &self,
            request: tonic::Request<super::AugmentPersonaRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AugmentPersonaRequestResponse>,
            tonic::Status,
        >;
    }
    /// RAGPersonaIntegrationService provides methods for integrating RAG and Persona
    #[derive(Debug)]
    pub struct RagPersonaIntegrationServiceServer<T: RagPersonaIntegrationService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: RagPersonaIntegrationService> RagPersonaIntegrationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for RagPersonaIntegrationServiceServer<T>
    where
        T: RagPersonaIntegrationService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/intellirouter.rag_manager.v1.RAGPersonaIntegrationService/AugmentPersonaRequest" => {
                    #[allow(non_camel_case_types)]
                    struct AugmentPersonaRequestSvc<T: RagPersonaIntegrationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: RagPersonaIntegrationService,
                    > tonic::server::UnaryService<super::AugmentPersonaRequestRequest>
                    for AugmentPersonaRequestSvc<T> {
                        type Response = super::AugmentPersonaRequestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AugmentPersonaRequestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RagPersonaIntegrationService>::augment_persona_request(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AugmentPersonaRequestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: RagPersonaIntegrationService> Clone
    for RagPersonaIntegrationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: RagPersonaIntegrationService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: RagPersonaIntegrationService> tonic::server::NamedService
    for RagPersonaIntegrationServiceServer<T> {
        const NAME: &'static str = "intellirouter.rag_manager.v1.RAGPersonaIntegrationService";
    }
}
